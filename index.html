<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Delaunay Refinement Algorithms</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<script src="lib/js/deployggb.js"></script>
		<!-- Geometry Graph Delaunay Stuff -->
		<script src="lib/js/jquery-1.11.2.min.js"></script>
		<script src="lib/js/jcanvas.min.js"></script>
		<script src="lib/js/queue.min.js"></script>
		<script src="js/geometry.js"></script>
		<script src="js/graph.js"></script>
		<script src="js/triangulate.js"></script>
		<script src="js/models/ty.js"></script>
        <script src="js/models/key.js"></script>

        <style>
			.ggb{
				display: inline-block;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<textarea data-template>
						# Delaunay Refinement

						Christian Weber, Moritz Rieger


						Hagen, 23.02.2018
					</textarea>
				</section>
                <section id="key" data-state="key">
                    <h2>Delaunay Refinement</h2>
                    <canvas class="center-block" width="900" height="500"></canvas>
                    <div>
                        <a onclick="refineKey(true)">start refinement</a>
                    </div>
                </section>
                <section data-markdown>
                    <textarea data-template>
						## Inhalt
						 - Was ist ein Delaunay Graph?
						 - Wofür braucht man Delaunay Graphen?
						 - Grundbegriffe
						 - Rupperts Refinement Algorithmus
						 - Chews Refinement Algorithmus
						 - Ausblick
					</textarea>
                </section>

                <!-- MOTIVATION -->
                <section>
                    <section data-markdown>
					<textarea data-template>
						## Wofür braucht man Delaunay Graphen?
					</textarea>
                    </section>
                    <section data-markdown>
                        <!-- TODO -->
                        <textarea data-template>
                            ### Finite Elemente Methode
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### 3D Computergrafik
                            ![https://straypixels.net/delaunay-triangulation-terrain](assets/img/BunnyWire.gif)
                        </textarea>
                    </section>
                    <section>
                        <h3>Face tracking</h3>
                        <!-- TODO better find another video or host it offline -->
                        <iframe width="560" height="315" src="https://www.youtube.com/embed/Zes2LivGozI?rel=0&amp;controls=0&amp;showinfo=0" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### Und weil es einfach gut aussieht!
                            ![http://hendrix.glitchartistscollective.com/post/95855206421/fifty-frames-of-twigs](http://78.media.tumblr.com/69f752d6a0ff4d679fa25356aeb60a9b/tumblr_naxomdFoPP1qe0j80o1_500.gif)
                        </textarea>
                    </section>
                </section>

                <!-- EINFÜHRUNG -->
                <section>
                    <section data-markdown>
                        <textarea data-template>
                            ## Was ist ein Delaunay Graph?
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ## Ausgangslage
                            ### Planar Straight Line Graph
                            - Knoten
                            - Segmente
                            - segment-gebunden
                            - in einer Ebene

                            ![PSLG aus 1](assets/img/pslg-segments.png)
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### PSLG triangulieren
                            ![PSLG aus 1](assets/img/pslg-segments.png) ![PSLG aus 1](assets/img/pslg-subsegments.png)
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ## Was macht Delaunay Graphen so besonders?
                        </textarea>
                    </section>
                    <section>
                        <h3>Umkreisbedinung</h3>
                        <div class="ggb" id="GpjaA7B9"></div>
                    </section>
                    <section>
                        <h3>Constrained Delaunay</h3>
                        <!--TODO @chris sichtbarkeit von Punkten erklären!-->
                        <div class="ggb" id="qKBrMvjR"></div>
                    </section>
                </section>

                <!-- GRUNDBEGRIFFE -->
                <section>
                    <section data-markdown>
                        <textarea data-template>
                            ## Grundbegriffe
                        </textarea>
                    </section>
                    <section>
                        <h2>Encroached Subsegments</h2>
                        <div class="ggb" id="E975hBTQ"></div>
                    </section>
                    <section>
                        <h2>Skinny Triangles</h2>
                        <p>Verhältnis von Umkreisradius zur kürzesten Kante<p>
                        <div class="ggb" id="D7XYwPfW"></div>
                    </section>
                </section>

                <!-- RUPPERT -->
                <section>
                    <section data-markdown>
                        <textarea data-template>
                            ## Rupperts Refinement Algorithmus
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### Ablauf

                            1. Teile encroached subsegments
                            2. Entferne skinny triangles
                        </textarea>
                    </section>
                    <section>
                        <h3>1. encroached subsegments teilen</h3>
                        <div class="ggb" id="dCUjJyYC"></div>
                    </section>
                    <section>
                        <h3>2. skinny triangles entfernen</h3>
                        <h4>1. Fall - durch den neuen Knoten enstehen encroached subsegments</h4>
                        <div class="ggb" id="AV8DJmbp"></div>
                    </section>
                    <section>
                        <h3>2. skinny triangles entfernen</h3>
                        <h4>2. Fall - durch den neuen Knoten enstehen keine encroached subsegments</h4>
                        <!-- TODO @chris kannst du hier bitte noch dein geogebra welches wir hier auch im skript Abb 10 a,b) verwendet haben einsetzten? Vllt kannst du auch noch ein paar segmente kennzeichnen indem du sie dicker machst - danke!-->
                    </section>
                    <section>
                        <!-- TODO weiter ausarbeiten ggb anpassen-->
                        <h3>Wieso in dieser Reihenfolge?</h3>
                        <p>Wenn keine encroached subsegments vorhanden sind, liegen neue Knoten immer innerhalb des Graphen</p>
                        <div class="ggb" id="NS2jCyfX"></div>
                        <aside class="notes" data-markdown>
                            **Vorraussetzungen:**
                            - Triangulation ist segement-gebunden
                            - keine encroached subsegments mehr
                            - v liegt innerhalb von t
                            - Schwerpunkt c immer innerhalb

                            **Widerspruchsbeweis:**
                            - V liegt ausserhalb
                            - cv muss segment s schneiden
                            - Teil des Umkreises von t auf selber seite von c wie s muss im Durchmesserkreis von s liegen
                            - es können aber nur max. 2 Punkte von t (Endpunkte von s) auf dem Druchmesserkreis von s liegen.
                            - mind. 1 Punkt liegt also im Durchmesserkreis -> **Widerspruch - keine encroached subsegments**
                        </aside>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### Terminierungsbeweis
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            Beim entfernen von Skinny Triangles können neue Skinny Triangles entstehen.
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            #### Idee
                            Zeigen, dass eine untere Schranke für die Länge neuer Kanten existiert.
                        </textarea>
                    </section>
                    <section>
                        <h4>Gilt nur unter diesen Bedingungen:</h4>
                        <div>
                            <ul>
                                <li>Schranke \( B \ge \sqrt{2}\)</li>
                                <li>kleinster Winkel \( \alpha \ge 60 \)°</li>
                            </ul>
                        </div>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### Sorry
                            wir benötigen noch einige Definitionen
                        </textarea>
                    </section>
                    <section>
                        <!--TODO GGB applet skript fixen, oder statisch machen.-->
                        <h3>local feature size</h3>
                        <p>kleinster Umkreis eines Punktes welcher zwei nicht inzidente Merkmale enthält</p>
                        <div class="ggb" id="Jbf6D8ax"></div>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### Einfügeradius
                            Länge der kürzesten Kante an einem Knoten v nachdem er eingefügt wurde.
                        </textarea>
                        <aside class="notes" data-markdown>
                            Abhängig von der Art des Knotens bzw. weshalb der Knoten eingefügt wurde.
                            Genau zu dem **Zeitpunkt**.
                        </aside>
                    </section>
                    <section>
                        <h3>Einfügeradius</h3>
                        <h4>Eingabeknoten (PSLG)</h4>
                        <img src="assets/img/ruppert/insertion-radius-1.png">
                        <aside class="notes" data-markdown>
                            Distanz zum nächsten Input Knoten
                        </aside>
                    </section>
                    <section>
                        <h3>Einfügeradius</h3>
                        <h4>Segmentknoten (encroached subsegment)</h4>
                        <img src="assets/img/ruppert/insertion-radius-2.png">
                        <aside class="notes">
                            Distanz zum nächsten verursachenden knoten
                        </aside>
                    </section>
                    <section>
                        <h3>Einfügeradius</h3>
                        <h4>verworfene Knoten (skinny triangle)</h4>
                        <img src="assets/img/ruppert/insertion-radius-3.png">
                        <aside class="notes">
                            Da Verursacher nichtmehr vorhanden rv ist Länge eines entstandenen Subsegments
                        </aside>
                    </section>
                    <section>
                        <h3>Einfügeradius</h3>
                        <h4>freie Knoten (skinny triangle)</h4>
                        <img src="assets/img/ruppert/insertion-radius-4.png">
                        <aside class="notes">
                           Umkreis des skinn triangles aufgrunddessen v eingefügt wurde
                        </aside>
                    </section>
                    <section>
                        <h3>Elternknoten</h3>
                        <h4>beschreiben Herkunft eines Knotens</h4>
                        <img src="assets/img/ruppert/rup-parent-vertices.png">
                        <aside class="notes" data-markdown>
                            - input knoten -> haben keinen Elternknoten
                            - segment Knoten -> p(v) verursachender Knoten
                            - freie Knoten (skinny) -> p(v) zuletzt eingefu ̈gte Knoten auf der ku ̈rzesten Kante des Dreiecks.
                            So entsteht die *Geschichte* des Graphen
                        </aside>
                    </section>
                    <section>
                        <h4>Änderung des Einfügeradius bei Kindsknoten</h4>
                        <img src="assets/img/ruppert/rup-flowchart.png">
                        <div>
                            <ul>
                                <li>Schranke \( B \ge \sqrt{2}\)</li>
                                <li>kleinster Winkel \( \alpha \ge 60 \)°</li>
                            </ul>
                        </div>
                        <aside class="notes" data-markdown>
                            - sqrt(2)/sqrt(2) = 1
                            - cos(60) = 1/2 ->
                        </aside>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### Was ist mit Kindern von Input Knoten?
                        </textarea>
                    </section>
                    <section>
                        <h4>Kindsknoten von Input-Knoten</h4>
                        <p>\( r_v \ge lfs(v) \)</p>
                        <!--
                        <div class="ggb" id="ndJWMvZK"></div>
                        -->
                        <div class="ggb" id="DKSpnBf7"></div>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### Woher kommen die anderen Werte?
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            Dazu betrachten wir die Beziehung der Einfügeradien ziwschen Eltern und Kindsknoten.
                        </textarea>
                    </section>
                    <section>
                        <!--TODO vllt. noch etwas verständlicher machen B in Applet einbauen-->
                        <h4>Kindsknoten von freien Knoten</h4>
                        <p>\(r_v \ge B*r_p\)</p>
                        <div class="ggb" id="QFJFVSXu"></div>
                    </section>
                    <!--Todo hier auch noch genauer durchgehen -> annotations-->
                    <section>
                        <h4>Segment Knoten - verworfener Elternknoten</h4>
                        <p>\( r_v \ge \frac{1}{\sqrt(2)} \)</p>
                        <div class="ggb" id="a7zr7JDf"></div>
                        <aside class="notes" data-markdown>
                            Hier kommt noch hilfestellung.
                        </aside>
                    </section>
                    <section>
                       Diese Betrachtungen sind ausreichend um die Terminierung bei Graphen deren kleinster Winkel \( \ge 90° \) ist zu beweisen.
                    </section>
                    <section>
                        Da wir aber Graphen mit kleinsten Winkeln \( \ge 60° \) unterstützen, müssen wir noch weitere Fälle untersuchen.
                    </section>
                    <section>
                        <h4>Kindsknoten von Segment Knoten</h4>
                        <p>p und v auf inzidenten Kanten \( 45° \le \alpha < 90° \) </p>
                        <p>\( r_v > \frac{r_p}{2\cos{\alpha}} \)</p>
                        <div class="ggb" id="CD56Amyj"></div>
                        <aside class="notes" data-markdown>
                            s is encroached by p
                            Winkel s, rp is fix
                            rp/rv wird dann am kleinsten, wenn p auf dem Durchmesserkreis von s liegt
                            basic Trigonometry s = rp / cos(alpha) -> rv ist halb so groß! rp/2 cos(alpha)
                        </aside>
                    </section>
                    <!--TODO - überprüfen ob man das nicht weglassen kann, da Winkel kleiner 60 eh ausgeschlossen sind!?-->
                    <section>
                        <h4>Kindsknoten von Segment Knoten</h4>
                        <p>p und v auf inzidenten Kanten \( \alpha \le 45° \) </p>
                        <p>\( r_v \ge r_p * sin(\alpha) \)</p>
                        <div class="ggb" id="z5VVcUMA"></div>
                        <aside class="notes" data-markdown>

                        </aside>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ### Was bedeuted das alles?
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            Da keine Knoten mit kleiner werdenden Einfügeradien enstehen können.
                            Können auch nicht kleinere Kanten als schon bestehende Merkmale im Graphen entstehen.
                        </textarea>
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            Dadurch ist bewiesen, dass der Algorithmus terminiert.
                        </textarea>
                    </section>
                </section>

                <!-- CHEW -->
                <section>
                    <section data-markdown>
                        <textarea data-template>
                            ## Chews Refinement Algorithmus
                        </textarea>
                    </section>
                </section>
				<section id="ty" data-state="ty">
					<canvas class="center-block" width="900" height="800"></canvas>
				</section>
			</div>
		</div>

	</body>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
            width: "100%",
            height: "100%",
            margin: 0,
            minScale: 1,
            maxScale: 1,
            math: {
                mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
                config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
            },
            dependencies: [
                { src: 'plugin/math/math.js', async: true },
                { src: 'plugin/markdown/marked.js' },
                { src: 'plugin/markdown/markdown.js' },
                { src: 'plugin/notes/notes.js', async: true },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
            ]
        });
    </script>
    <script src="js/ggb.js"></script>
    <script src="js/triangulations.js"></script>
</html>
